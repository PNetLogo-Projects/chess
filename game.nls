to game-initialize-constants
  set game-white-turn white
  set game-black-turn black
  set game-white-color white
  set game-black-color black
end

to game-initialize-globals
  set game-turn game-white-turn
  set game-turn-color game-white-color
  set game-selected-piece nobody
  set game-last-moved-piece nobody
  set game-last-move-was-capture? false
  set game-fifty-moves-rule-counter 0
  set game-move-history []
end

to new-game
  setup-game
  main-loop
end

to setup-game
  ca
  initialize-constants
  initialize-globals
  
  render-board
  render-pieces
  sync-screen
end

to main-loop
  let game-over false
  let mouse-up? (not mouse-down?)

  while [not game-over]
  [
    if not mouse-down?
    [set mouse-up? true]
    if mouse-inside? and mouse-down? and mouse-up? and mouse-xcor >= 0 and mouse-xcor <= 7
    [
      set mouse-up? false
      handle-user-input
    ]
  ]
end

to handle-user-input
  let mouse-x round mouse-xcor
  let mouse-y round mouse-ycor
  let patches-at-mouse-coordinates (patches with [pxcor = mouse-x and pycor = mouse-y])
  
  ask patches-at-mouse-coordinates
  [
    if any? turtles-here with [color = game-turn-color]
    [
      set game-selected-piece one-of turtles-here
      ask game-selected-piece
      [pieces-mark-valid-moves]
    ]
    if not any? turtles-here with [color = game-turn-color] and (within-board-bounds? mouse-x mouse-y)
    [
      update-game-move-history
      set game-last-move-was-capture? false
      if marked?
      [
        ask game-selected-piece
        [
          setxy mouse-x mouse-y
          pieces-assess-if-move-was-special
          set moved? true
          ask other turtles-here
          [
            set game-last-move-was-capture? true
            die
          ]
          set game-last-moved-piece self
        ]
        set game-selected-piece nobody
        advance-fifty-moves-rule-counter
        reset-marks
        next-turn
      ]
    ]
  ]
end

to update-game-move-history
  set game-move-history (lput (save-game-to-fen-notation) game-move-history)
end

to undo
  if length game-move-history > 0
  [
    let last-move (last game-move-history)
    set game-move-history (but-last game-move-history)
    load-game-from-fen-notation (last-move)
  ]
end

to-report game-over-by-checkmate?
  reset-marks
  ask kings with [color = game-turn-color]
  [
    ask pieces-allies
    [pieces-mark-valid-moves]
  ]
  report not any? patches with [marked?]
end

to-report game-draw-by-fifty-moves-rule?
  report game-fifty-moves-rule-counter >= 50
end

to-report game-draw-by-threefold-repetition?
  let current-move-fen-notation save-game-to-fen-notation
  let current-position (item 0 current-move-fen-notation)
  let current-turn (item 3 current-move-fen-notation)
  let castling-rights (item 4 current-move-fen-notation)
  let enpassant-rights (item 5 current-move-fen-notation)
  
  let repetition 0
  foreach game-move-history
  [
    move ->
    
    if (current-position = (item 0 move) and current-turn = (item 3 move) and castling-rights = (item 4 move) and
      enpassant-rights = (item 5 move))
    [set repetition (repetition + 1)]
  ]
  
  show repetition
  report repetition >= 3
end

to advance-fifty-moves-rule-counter
  ifelse [breed] of game-last-moved-piece != pawns and not game-last-move-was-capture?
  [set game-fifty-moves-rule-counter (game-fifty-moves-rule-counter + 1)]
  [set game-fifty-moves-rule-counter 0]
end

to next-turn
  ifelse game-turn = game-white-turn
  [
    set game-turn game-black-turn
    set game-turn-color game-black-color
  ]
  [
    set game-turn game-white-turn
    set game-turn-color game-white-color
  ]
end